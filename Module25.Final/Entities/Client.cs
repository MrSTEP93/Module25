using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Module25.Final.Entities
{
    public class Client
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Surname { get; set; }
        public string Email { get; set; }

        //public List<Book> Books { get; set; } = new List<Book>();
        public List<Book> Books { get; set; }


        /// Вот по последнему свойству Books у меня вопрос. В уроке сказано, что для навиг.св-ва надо добавить инициализацию списка:  new List<Т>();
        /// Да, тогда при создании и заполнении БД всё отрабатывает отлично - у клиентов появляется список книг (List<Book> Books), независимо от того, 
        /// прописываю ли я ID клиента в книгу или же добавляю книгу в список клиенту (Метод FillBooksWithClient() в классе Prorgam). 
        /// Как говорилось в уроке, связь работает в обе стороны, ок
        /// ...
        /// Но засада в том, что когда я выбираю из базы существующих клиентов, отрабатывает этот же самый конструктор, 
        /// и затирает имеющийся в базе List<Book> новым пустым списком. Соответственно, дальнейшая работа с ним невозможна.
        /// Я попробовал добавить инициализацию этого списка в ClientRepository.AddClient(), и это должно сработать, пожалуй.
        /// Но является ли это нормальным выходом из ситуации?? Ведь формально мы можем добавлять килентов напрямую через контекст db.Clients.Add,
        /// и тогда Books будет равен Null. 
        /// Следовательно, все пользователи, добавленные через контекст, получатся кривыми, и добавить им книгу мы не сможем.
        /// ...
        /// Собственно, вопрос: Так как же лучше поступить в этой ситуации?
        /// (и риторический вопрос: а как будет работать пример из урока, где жестко прописана инициализация пустым списком?)

    }
}
